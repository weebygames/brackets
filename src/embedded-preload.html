<!doctype html>

<html manifest="brackets.appcache">
<head>
<meta charset="utf-8">
<script type="application/javascript">

/**
 * @param  {Object} data
 */
function postMessage(data) {
  data.type = 'appcache';
  data.sender = 'Brackets';
  var message = JSON.stringify(data);
  if (window.parent === window) {
    console.log('parent === this, logging instead:', message);
  } else {
    window.parent.postMessage(message, '*');
  }
}

var appCache = window.applicationCache;
postMessage({ status: 'init' });

function handleCacheEvent(e) {
  if (e.type === 'progress') {
    postMessage({ status: e.type, progress: e.loaded / e.total });
  }
  else {
    postMessage({ status: e.type });
  }
}

function handleCacheError(err) {
  postMessage({ status: 'error', message: err.stack });
};

// Fired after the first cache of the manifest.
appCache.addEventListener('cached', handleCacheEvent, false);
// Checking for an update. Always the first event fired in the sequence.
appCache.addEventListener('checking', handleCacheEvent, false);
// An update was found. The browser is fetching resources.
appCache.addEventListener('downloading', handleCacheEvent, false);
// The manifest returns 404 or 410, the download failed,
// or the manifest changed while the download was in progress.
appCache.addEventListener('error', handleCacheError, false);
// Fired after the first download of the manifest.
appCache.addEventListener('noupdate', handleCacheEvent, false);
// Fired if the manifest file returns a 404 or 410.
// This results in the application cache being deleted.
appCache.addEventListener('obsolete', handleCacheEvent, false);
// Fired for each resource listed in the manifest as it is being fetched.
appCache.addEventListener('progress', handleCacheEvent, false);
// Fired when the manifest resources have been newly redownloaded.
appCache.addEventListener('updateready', handleCacheEvent, false);

</script>
</head>
<body>
Preloading appcache!
</body>
</html>
